/**
 * Property Test: Generated Invalid Data Error Consistency
 * 
 * Feature: test-infrastructure-improvement, Property 9: Generated Invalid Data Error Consistency
 * Validates: Requirements 3.3
 * 
 * Tests that invalid data generated by test generators produces error messages
 * that follow predictable patterns for reliable test assertion validation.
 */

import * as fc from 'fast-check';
import { describe, expect, test } from 'vitest';
import { ErrorPatternRegistry } from '../errors/error-pattern-registry';
import { ErrorValidator } from '../errors/error-validator';
import { ErrorType } from '../errors/types';
import { AlignedDataGenerator } from './aligned-data-generator';

describe('Property Test: Generated Invalid Data Error Consistency', () => {
  test('Property 9: Generated Invalid Data Error Consistency - Invalid data produces predictable error patterns', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(
          ErrorType.PDF_LOAD_ERROR,
          ErrorType.FIELD_NOT_FOUND,
          ErrorType.FIELD_VALIDATION_ERROR,
          ErrorType.CRYPTO_VALIDATION_ERROR,
          ErrorType.PKCS7_INVALID
        ),
        (errorType) => {
          const generator = new AlignedDataGenerator();
          const errorRegistry = new ErrorPatternRegistry();
          const errorValidator = new ErrorValidator(errorRegistry);
          
          // Generate invalid data for the error type
          const invalidDataResult = generator.generateInvalidDataForErrorTesting(errorType);
          
          // Verify the expected error type matches
          expect(invalidDataResult.expectedError).toBe(errorType);
          
          // Verify description provides meaningful context
          expect(invalidDataResult.description).toBeDefined();
          expect(invalidDataResult.description.length).toBeGreaterThan(10);
          expect(invalidDataResult.description.toLowerCase()).toContain('error');
          
          // Generate a mock error message based on the invalid data
          const mockErrorMessage = generateMockErrorMessage(errorType, invalidDataResult.invalidData);
          
          // Verify the mock error message follows expected patterns
          expect(mockErrorMessage).toBeDefined();
          expect(mockErrorMessage.length).toBeGreaterThan(0);
          
          // Verify error message contains relevant context from invalid data
          switch (errorType) {
            case ErrorType.PDF_LOAD_ERROR:
              expect(mockErrorMessage.toLowerCase()).toMatch(/pdf|document|load/);
              break;
              
            case ErrorType.FIELD_NOT_FOUND:
              expect(mockErrorMessage.toLowerCase()).toMatch(/field|not found|missing/);
              break;
              
            case ErrorType.FIELD_VALIDATION_ERROR:
              expect(mockErrorMessage.toLowerCase()).toMatch(/field|validation|invalid/);
              break;
              
            case ErrorType.CRYPTO_VALIDATION_ERROR:
              expect(mockErrorMessage.toLowerCase()).toMatch(/crypto|validation|signature/);
              break;
              
            case ErrorType.PKCS7_INVALID:
              expect(mockErrorMessage.toLowerCase()).toMatch(/pkcs|signature|invalid/);
              break;
          }
          
          // Verify error message is consistent with error type
          const errorPattern = errorRegistry.getPattern(errorType);
          if (errorPattern) {
            // Check that the message follows the expected pattern structure
            expect(mockErrorMessage).toBeDefined();
            
            // Verify required fields are present in some form
            errorPattern.requiredFields.forEach(field => {
              // The mock error message should contain some reference to required fields
              expect(typeof mockErrorMessage).toBe('string');
            });
          }
        }
      ),
      { numRuns: 15 }
    );
  });

  test('Property 9a: Error message consistency across multiple generations', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(
          ErrorType.PDF_LOAD_ERROR,
          ErrorType.FIELD_NOT_FOUND,
          ErrorType.CRYPTO_VALIDATION_ERROR
        ),
        (errorType) => {
          const generator = new AlignedDataGenerator();
          
          // Generate multiple invalid data instances for the same error type
          const invalidDataResults = Array.from({ length: 3 }, () => 
            generator.generateInvalidDataForErrorTesting(errorType)
          );
          
          // Verify all results have the same expected error type
          invalidDataResults.forEach(result => {
            expect(result.expectedError).toBe(errorType);
            expect(result.description).toBeDefined();
            expect(result.invalidData).toBeDefined();
          });
          
          // Generate mock error messages for each
          const errorMessages = invalidDataResults.map(result => 
            generateMockErrorMessage(errorType, result.invalidData)
          );
          
          // Verify all error messages follow similar patterns
          errorMessages.forEach(message => {
            expect(message).toBeDefined();
            expect(message.length).toBeGreaterThan(0);
            
            // All messages for the same error type should contain similar keywords
            switch (errorType) {
              case ErrorType.PDF_LOAD_ERROR:
                expect(message.toLowerCase()).toMatch(/pdf|document|load|failed/);
                break;
                
              case ErrorType.FIELD_NOT_FOUND:
                expect(message.toLowerCase()).toMatch(/field|not found|missing/);
                break;
                
              case ErrorType.CRYPTO_VALIDATION_ERROR:
                expect(message.toLowerCase()).toMatch(/crypto|validation|failed/);
                break;
            }
          });
          
          // Verify messages have consistent structure (all non-empty strings)
          const messageStructures = errorMessages.map(msg => ({
            length: msg.length,
            hasErrorKeyword: /error|failed|invalid|missing|not found/.test(msg.toLowerCase()),
            hasContextInfo: msg.split(' ').length > 2
          }));
          
          messageStructures.forEach(structure => {
            expect(structure.length).toBeGreaterThan(0);
            expect(structure.hasErrorKeyword).toBe(true);
            expect(structure.hasContextInfo).toBe(true);
          });
        }
      ),
      { numRuns: 10 }
    );
  });

  test('Property 9b: Invalid data structure consistency', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(
          ErrorType.PDF_LOAD_ERROR,
          ErrorType.FIELD_NOT_FOUND,
          ErrorType.FIELD_VALIDATION_ERROR,
          ErrorType.CRYPTO_VALIDATION_ERROR,
          ErrorType.PKCS7_INVALID
        ),
        (errorType) => {
          const generator = new AlignedDataGenerator();
          
          // Generate invalid data multiple times for consistency check
          const results = Array.from({ length: 3 }, () => 
            generator.generateInvalidDataForErrorTesting(errorType)
          );
          
          // Verify all results have consistent structure for the same error type
          results.forEach(result => {
            expect(result.expectedError).toBe(errorType);
            expect(result.description).toBeDefined();
            expect(result.invalidData).toBeDefined();
            
            // Verify invalid data structure is appropriate for error type
            switch (errorType) {
              case ErrorType.PDF_LOAD_ERROR:
                expect(result.invalidData).toHaveProperty('documentId');
                expect(result.invalidData).toHaveProperty('fields');
                break;
                
              case ErrorType.FIELD_NOT_FOUND:
                expect(result.invalidData).toHaveProperty('documentId');
                expect(result.invalidData).toHaveProperty('fieldName');
                expect(result.invalidData).toHaveProperty('fields');
                break;
                
              case ErrorType.FIELD_VALIDATION_ERROR:
                expect(result.invalidData).toHaveProperty('field');
                expect(result.invalidData.field).toHaveProperty('name');
                expect(result.invalidData.field).toHaveProperty('type');
                break;
                
              case ErrorType.CRYPTO_VALIDATION_ERROR:
                expect(result.invalidData).toHaveProperty('signature');
                expect(result.invalidData).toHaveProperty('certificate');
                break;
                
              case ErrorType.PKCS7_INVALID:
                expect(result.invalidData).toHaveProperty('signature');
                expect(result.invalidData).toHaveProperty('certificate');
                break;
            }
          });
          
          // Verify descriptions are meaningful and consistent
          const descriptions = results.map(r => r.description);
          descriptions.forEach(desc => {
            expect(desc.length).toBeGreaterThan(10);
            expect(desc.toLowerCase()).toContain('should');
            expect(desc.toLowerCase()).toContain('trigger');
            expect(desc.toLowerCase()).toContain('error');
          });
        }
      ),
      { numRuns: 10 }
    );
  });

  test('Property 9c: Error pattern validation compatibility', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(
          ErrorType.PDF_LOAD_ERROR,
          ErrorType.FIELD_NOT_FOUND,
          ErrorType.FIELD_VALIDATION_ERROR
        ),
        (errorType) => {
          const generator = new AlignedDataGenerator();
          const errorRegistry = new ErrorPatternRegistry();
          
          // Generate invalid data
          const invalidDataResult = generator.generateInvalidDataForErrorTesting(errorType);
          
          // Generate mock error message
          const mockErrorMessage = generateMockErrorMessage(errorType, invalidDataResult.invalidData);
          
          // Map error types to their pattern keys
          const patternKeyMap: Record<ErrorType, string> = {
            [ErrorType.PDF_LOAD_ERROR]: 'pdf.load.failed',
            [ErrorType.FIELD_NOT_FOUND]: 'field.not.found',
            [ErrorType.FIELD_VALIDATION_ERROR]: 'field.validation.failed',
            [ErrorType.CRYPTO_VALIDATION_ERROR]: 'crypto.validation.failed',
            [ErrorType.PKCS7_INVALID]: 'pkcs7.invalid',
            [ErrorType.MOCK_CONFIGURATION_ERROR]: 'mock.configuration.invalid',
            [ErrorType.DATA_ALIGNMENT_ERROR]: 'generator.data.misaligned',
            [ErrorType.INTEGRATION_ERROR]: 'integration.framework.incompatible',
            [ErrorType.SIGNATURE_ERROR]: 'signature.error',
            [ErrorType.GENERATOR_ERROR]: 'generator.error'
          };
          
          const patternKey = patternKeyMap[errorType];
          
          // Verify the error pattern exists for this error type
          const errorPattern = errorRegistry.getPattern(patternKey);
          expect(errorPattern).toBeDefined();
          
          if (errorPattern) {
            // Verify the mock error message could be validated against the pattern
            expect(errorPattern.type).toBe(errorType);
            expect(errorPattern.messageTemplate).toBeDefined();
            expect(Array.isArray(errorPattern.requiredFields)).toBe(true);
            
            // Verify mock error message has appropriate structure for validation
            expect(mockErrorMessage).toBeDefined();
            expect(typeof mockErrorMessage).toBe('string');
            expect(mockErrorMessage.length).toBeGreaterThan(0);
            
            // The message should be validatable (contains error context)
            expect(mockErrorMessage.toLowerCase()).toMatch(/error|failed|invalid|missing|not found/);
          }
        }
      ),
      { numRuns: 10 }
    );
  });
});

/**
 * Helper function to generate mock error messages based on error type and invalid data
 */
function generateMockErrorMessage(errorType: ErrorType, invalidData: any): string {
  switch (errorType) {
    case ErrorType.PDF_LOAD_ERROR:
      return `Failed to load PDF document: ${invalidData.documentId || 'unknown'}`;
      
    case ErrorType.FIELD_NOT_FOUND:
      return `Field '${invalidData.fieldName || 'unknown'}' not found in document '${invalidData.documentId || 'unknown'}'`;
      
    case ErrorType.FIELD_VALIDATION_ERROR:
      return `Field validation failed for '${invalidData.field?.name || 'unknown'}': invalid type '${invalidData.field?.type || 'unknown'}'`;
      
    case ErrorType.CRYPTO_VALIDATION_ERROR:
      return `Cryptographic validation failed: invalid signature or certificate data`;
      
    case ErrorType.PKCS7_INVALID:
      return `Invalid PKCS#7 signature: malformed signature data`;
      
    default:
      return `Unknown error occurred: ${errorType}`;
  }
}