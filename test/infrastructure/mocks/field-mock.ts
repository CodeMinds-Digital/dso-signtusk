/**
 * Field Mock Implementation
 * 
 * Simulates PDF form field lookup and validation for testing purposes.
 * Provides consistent field information and validation rule processing.
 */

import { ErrorType, ValidationRule, ValidationRuleType } from '../errors/types';
import { RealisticErrorPatterns } from './realistic-error-patterns';
import {
    FieldDefinition,
    FieldType,
    MockConfiguration,
    ValidationResult
} from './types';

// Create a singleton instance for use in this mock
const realisticErrorPatterns = new RealisticErrorPatterns();

export class FieldMock {
  private fieldRegistry: Map<string, FieldDefinition[]> = new Map();
  private validationCache: Map<string, ValidationResult> = new Map();
  private configuration: Partial<MockConfiguration['pdf']>;
  private lookupHistory: Array<{ documentId: string; fieldName?: string; timestamp: Date }> = [];
  private realisticScenarioContext?: Record<string, any>;

  constructor(configuration?: Partial<MockConfiguration['pdf']>) {
    this.configuration = configuration || {};
  }

  /**
   * Register fields for a document
   */
  registerFields(documentId: string, fields: FieldDefinition[]): void {
    this.fieldRegistry.set(documentId, [...fields]);
    this.recordLookup(documentId);
  }

  /**
   * Lookup all fields for a document
   */
  lookupFields(documentId: string): FieldDefinition[];
  lookupFields(fieldNames: string[], documentId: string): FieldDefinition[];
  lookupFields(documentIdOrFieldNames: string | string[], documentIdOrSecondParam?: string): FieldDefinition[] {
    // Handle overloaded method signatures
    let documentId: string;
    let fieldNames: string[] | undefined;

    if (Array.isArray(documentIdOrFieldNames)) {
      // Called with (fieldNames, documentId)
      fieldNames = documentIdOrFieldNames;
      documentId = documentIdOrSecondParam!;
    } else {
      // Called with (documentId)
      documentId = documentIdOrFieldNames;
    }

    this.recordLookup(documentId);

    const fields = this.fieldRegistry.get(documentId);
    if (!fields) {
      throw new Error(this.getErrorMessage(ErrorType.PDF_LOAD_ERROR, { documentId }));
    }

    // If specific field names were requested, filter to those
    let resultFields = fields;
    if (fieldNames) {
      resultFields = fields.filter(field => fieldNames!.includes(field.name));
    }

    // Return consistent results - deep copy to prevent external modification
    return resultFields.map(field => ({ ...field, validation: [...field.validation] }));
  }

  /**
   * Lookup a specific field by name
   */
  lookupField(documentId: string, fieldName: string): FieldDefinition | null {
    this.recordLookup(documentId, fieldName);

    const fields = this.fieldRegistry.get(documentId);
    if (!fields) {
      throw new Error(this.getErrorMessage(ErrorType.PDF_LOAD_ERROR, { documentId }));
    }

    const field = fields.find(f => f.name === fieldName);
    if (!field) {
      return null;
    }

    // Return consistent result - deep copy
    return { ...field, validation: [...field.validation] };
  }

  /**
   * Validate field value against its validation rules
   */
  validateField(documentId: string, fieldName: string, value: string): ValidationResult {
    const cacheKey = `${documentId}:${fieldName}:${value}`;
    
    // Return cached result for consistency
    if (this.validationCache.has(cacheKey)) {
      return { ...this.validationCache.get(cacheKey)! };
    }

    // Check if validation behavior is configured to fail FIRST
    if (this.configuration.validationBehavior && !this.configuration.validationBehavior.shouldSucceed) {
      const result: ValidationResult = {
        isValid: false,
        errorType: this.configuration.validationBehavior.errorType || ErrorType.FIELD_VALIDATION_ERROR,
        message: this.configuration.validationBehavior.customMessage || this.getErrorMessage(
          this.configuration.validationBehavior.errorType || ErrorType.FIELD_VALIDATION_ERROR, 
          { documentId, fieldName, value }
        ),
        context: { 
          documentId, 
          fieldName, 
          value,
          // Extract context from the custom message if it was generated by realistic error patterns
          ...(this.extractContextFromMessage(this.configuration.validationBehavior.customMessage))
        }
      };
      this.validationCache.set(cacheKey, result);
      return { ...result };
    }

    const field = this.lookupField(documentId, fieldName);
    if (!field) {
      const result: ValidationResult = {
        isValid: false,
        errorType: ErrorType.FIELD_NOT_FOUND,
        message: this.getErrorMessage(ErrorType.FIELD_NOT_FOUND, { documentId, fieldName }),
        context: { documentId, fieldName }
      };
      this.validationCache.set(cacheKey, result);
      return { ...result };
    }

    // Process validation rules
    const validationResult = this.processValidationRules(field, value);
    this.validationCache.set(cacheKey, validationResult);
    
    return { ...validationResult };
  }

  /**
   * Check if field exists in document
   */
  hasField(documentId: string, fieldName: string): boolean {
    const fields = this.fieldRegistry.get(documentId);
    if (!fields) {
      return false;
    }
    return fields.some(f => f.name === fieldName);
  }

  /**
   * Get fields by type
   */
  getFieldsByType(documentId: string, fieldType: FieldType): FieldDefinition[] {
    const fields = this.lookupFields(documentId);
    return fields.filter(f => f.type === fieldType);
  }

  /**
   * Get required fields
   */
  getRequiredFields(documentId: string): FieldDefinition[] {
    const fields = this.lookupFields(documentId);
    return fields.filter(f => f.required);
  }

  /**
   * Get field count for document
   */
  getFieldCount(documentId: string): number {
    const fields = this.fieldRegistry.get(documentId);
    return fields ? fields.length : 0;
  }

  /**
   * Update field configuration
   */
  updateFieldConfiguration(documentId: string, fieldName: string, updates: Partial<FieldDefinition>): void {
    const fields = this.fieldRegistry.get(documentId);
    if (!fields) {
      throw new Error(this.getErrorMessage(ErrorType.PDF_LOAD_ERROR, { documentId }));
    }

    const fieldIndex = fields.findIndex(f => f.name === fieldName);
    if (fieldIndex === -1) {
      throw new Error(this.getErrorMessage(ErrorType.FIELD_NOT_FOUND, { documentId, fieldName }));
    }

    // Update field while maintaining consistency
    fields[fieldIndex] = { ...fields[fieldIndex], ...updates };
    
    // Clear validation cache for this field
    this.clearValidationCache(documentId, fieldName);
  }

  /**
   * Get lookup history for debugging
   */
  getLookupHistory(): Array<{ documentId: string; fieldName?: string; timestamp: Date }> {
    return [...this.lookupHistory];
  }

  /**
   * Clear validation cache for specific field or entire document
   */
  clearValidationCache(documentId?: string, fieldName?: string): void {
    if (!documentId) {
      this.validationCache.clear();
      return;
    }

    if (!fieldName) {
      // Clear all cache entries for document
      const keysToDelete = Array.from(this.validationCache.keys())
        .filter(key => key.startsWith(`${documentId}:`));
      keysToDelete.forEach(key => this.validationCache.delete(key));
      return;
    }

    // Clear cache entries for specific field
    const keysToDelete = Array.from(this.validationCache.keys())
      .filter(key => key.startsWith(`${documentId}:${fieldName}:`));
    keysToDelete.forEach(key => this.validationCache.delete(key));
  }

  /**
   * Reset mock to clean state
   */
  reset(): void {
    this.fieldRegistry.clear();
    this.validationCache.clear();
    this.lookupHistory = [];
    this.configuration = {};
  }

  /**
   * Get registered documents
   */
  getRegisteredDocuments(): string[] {
    return Array.from(this.fieldRegistry.keys());
  }

  /**
   * Configure realistic error scenarios for field validation
   */
  configureRealisticErrorScenario(errorType: ErrorType, context?: Record<string, any>): void {
    const realisticScenario = realisticErrorPatterns.generateRealisticError(errorType, context || {});
    
    // Configure validation behavior to trigger this error
    this.configuration.validationBehavior = {
      shouldSucceed: false,
      errorType: realisticScenario.errorType,
      customMessage: realisticScenario.message
    };
    
    // Store the realistic scenario context for later use
    this.realisticScenarioContext = realisticScenario.context;
  }

  private extractContextFromMessage(message?: string): Record<string, any> {
    if (!message) return {};
    
    // If we have stored realistic scenario context, use it
    if (this.realisticScenarioContext) {
      return this.realisticScenarioContext;
    }
    
    // Otherwise try to extract error code from message
    const errorCodeMatch = message.match(/Code:\s*(TST_\w+_\d+_\d+)/);
    if (errorCodeMatch) {
      return {
        errorCode: errorCodeMatch[1],
        severity: 'medium' // Default severity
      };
    }
    
    return {};
  }

  /**
   * Update mock configuration
   */
  updateConfiguration(config: Partial<MockConfiguration['pdf']>): void {
    this.configuration = { ...this.configuration, ...config };
  }

  /**
   * Get current configuration
   */
  getConfiguration(): Partial<MockConfiguration['pdf']> {
    return { ...this.configuration };
  }

  private processValidationRules(field: FieldDefinition, value: string): ValidationResult {
    // If no validation rules, field is valid
    if (!field.validation || field.validation.length === 0) {
      return {
        isValid: true,
        context: { fieldName: field.name, value }
      };
    }

    // Process each validation rule
    for (const rule of field.validation) {
      const ruleResult = this.validateRule(rule, value, field);
      if (!ruleResult.isValid) {
        return {
          isValid: false,
          errorType: ErrorType.FIELD_VALIDATION_ERROR,
          message: ruleResult.message || this.getErrorMessage(ErrorType.FIELD_VALIDATION_ERROR, { 
            fieldName: field.name, 
            rule: rule.type 
          }),
          context: { fieldName: field.name, value, rule: rule.type }
        };
      }
    }

    return {
      isValid: true,
      context: { fieldName: field.name, value }
    };
  }

  private validateRule(rule: ValidationRule, value: string, field: FieldDefinition): ValidationResult {
    switch (rule.type) {
      case ValidationRuleType.REQUIRED_FIELD:
        return {
          isValid: value.trim().length > 0,
          message: rule.message || `Field '${field.name}' is required`
        };

      case ValidationRuleType.LENGTH_VALIDATION:
        const maxLength = typeof rule.parameter === 'number' ? rule.parameter : 255;
        return {
          isValid: value.length <= maxLength,
          message: rule.message || `Field '${field.name}' exceeds maximum length of ${maxLength}`
        };

      case ValidationRuleType.FORMAT_VALIDATION:
        // Simple format validation - could be extended
        return {
          isValid: true, // Default to valid for mock
          message: rule.message
        };

      case ValidationRuleType.PATTERN_MATCH:
        if (typeof rule.parameter === 'string') {
          try {
            const regex = new RegExp(rule.parameter);
            return {
              isValid: regex.test(value),
              message: rule.message || `Field '${field.name}' does not match required pattern`
            };
          } catch {
            return {
              isValid: false,
              message: `Invalid pattern in validation rule for field '${field.name}'`
            };
          }
        }
        return { isValid: true };

      case ValidationRuleType.CUSTOM_VALIDATION:
        // Custom validation - configurable behavior
        return {
          isValid: this.configuration.validationBehavior?.shouldSucceed !== false,
          message: rule.message || this.configuration.validationBehavior?.customMessage
        };

      default:
        return { isValid: true };
    }
  }

  private recordLookup(documentId: string, fieldName?: string): void {
    this.lookupHistory.push({
      documentId,
      fieldName,
      timestamp: new Date()
    });
  }

  private getErrorMessage(errorType: ErrorType, context: Record<string, any>): string {
    // Use realistic error patterns for production-like error messages
    const errorScenario = realisticErrorPatterns.generateRealisticError(errorType, context);
    return errorScenario.message;
  }
}