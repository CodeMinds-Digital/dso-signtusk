#!/usr/bin/env node

/**
 * Netlify Domain Configuration Script
 * 
 * This script helps configure domain routing for multiple applications
 * deployed from a monorepo to separate Netlify sites.
 */

const fs = require('fs');
const path = require('path');

// Domain configuration for each application
const DOMAIN_CONFIG = {
  marketing: {
    primary: process.env.NETLIFY_MARKETING_DOMAIN || 'yourdomain.com',
    aliases: [
      process.env.NETLIFY_MARKETING_WWW || 'www.yourdomain.com'
    ],
    redirects: [
      // Redirect www to non-www
      {
        from: 'https://www.yourdomain.com/*',
        to: 'https://yourdomain.com/:splat',
        status: 301,
        force: true
      },
      // Redirect HTTP to HTTPS
      {
        from: 'http://yourdomain.com/*',
        to: 'https://yourdomain.com/:splat',
        status: 301,
        force: true
      },
      // Redirect old paths to new structure
      {
        from: '/home',
        to: '/',
        status: 301
      },
      {
        from: '/about-us',
        to: '/about',
        status: 301
      }
    ]
  },
  remix: {
    primary: process.env.NETLIFY_REMIX_DOMAIN || 'app.yourdomain.com',
    aliases: [],
    redirects: [
      // Redirect HTTP to HTTPS
      {
        from: 'http://app.yourdomain.com/*',
        to: 'https://app.yourdomain.com/:splat',
        status: 301,
        force: true
      },
      // Redirect old app paths
      {
        from: '/dashboard',
        to: '/app/dashboard',
        status: 301
      },
      {
        from: '/profile',
        to: '/app/profile',
        status: 301
      }
    ]
  },
  docs: {
    primary: process.env.NETLIFY_DOCS_DOMAIN || 'docs.yourdomain.com',
    aliases: [],
    redirects: [
      // Redirect HTTP to HTTPS
      {
        from: 'http://docs.yourdomain.com/*',
        to: 'https://docs.yourdomain.com/:splat',
        status: 301,
        force: true
      },
      // Redirect old documentation paths
      {
        from: '/documentation/*',
        to: '/docs/:splat',
        status: 301
      },
      {
        from: '/api-reference',
        to: '/api',
        status: 301
      }
    ]
  }
};

/**
 * Generate Netlify redirect rules for an application
 */
function generateRedirectRules(appName) {
  const config = DOMAIN_CONFIG[appName];
  if (!config) {
    throw new Error(`Unknown application: ${appName}`);
  }

  return config.redirects.map(redirect => {
    const rule = {
      from: redirect.from,
      to: redirect.to,
      status: redirect.status
    };

    if (redirect.force) {
      rule.force = true;
    }

    if (redirect.conditions) {
      rule.conditions = redirect.conditions;
    }

    return rule;
  });
}

/**
 * Generate domain configuration for Netlify site
 */
function generateDomainConfig(appName) {
  const config = DOMAIN_CONFIG[appName];
  if (!config) {
    throw new Error(`Unknown application: ${appName}`);
  }

  return {
    primary: config.primary,
    aliases: config.aliases,
    redirects: generateRedirectRules(appName)
  };
}

/**
 * Update Netlify TOML configuration with domain settings
 */
function updateNetlifyConfig(appName, configPath) {
  const domainConfig = generateDomainConfig(appName);
  
  console.log(`Updating domain configuration for ${appName}:`);
  console.log(`- Primary domain: ${domainConfig.primary}`);
  console.log(`- Aliases: ${domainConfig.aliases.join(', ') || 'None'}`);
  console.log(`- Custom redirects: ${domainConfig.redirects.length} rules`);

  // Read existing config
  let configContent = '';
  if (fs.existsSync(configPath)) {
    configContent = fs.readFileSync(configPath, 'utf8');
  }

  // Add domain-specific redirects to the config
  const redirectComments = `
# Domain-specific redirects for ${appName}
# Primary domain: ${domainConfig.primary}
# Generated by netlify-domain-config.js
`;

  const redirectRules = domainConfig.redirects.map(redirect => {
    let rule = `[[redirects]]
  from = "${redirect.from}"
  to = "${redirect.to}"
  status = ${redirect.status}`;

    if (redirect.force) {
      rule += `
  force = true`;
    }

    if (redirect.conditions) {
      rule += `
  conditions = ${JSON.stringify(redirect.conditions)}`;
    }

    return rule;
  }).join('\n\n');

  // Insert domain redirects at the beginning of the redirects section
  if (configContent.includes('[[redirects]]')) {
    // Replace the first redirect with our domain redirects + existing redirects
    const firstRedirectIndex = configContent.indexOf('[[redirects]]');
    const beforeRedirects = configContent.substring(0, firstRedirectIndex);
    const afterRedirects = configContent.substring(firstRedirectIndex);
    
    configContent = beforeRedirects + redirectComments + redirectRules + '\n\n' + afterRedirects;
  } else {
    // Add redirects at the end
    configContent += redirectComments + redirectRules + '\n';
  }

  fs.writeFileSync(configPath, configContent);
  console.log(`Updated ${configPath} with domain configuration`);

  return domainConfig;
}

/**
 * Generate _redirects file for additional redirect rules
 */
function generateRedirectsFile(appName, outputPath) {
  const domainConfig = generateDomainConfig(appName);
  
  const redirectsContent = domainConfig.redirects.map(redirect => {
    let line = `${redirect.from} ${redirect.to} ${redirect.status}`;
    
    if (redirect.force) {
      line += '!';
    }

    return line;
  }).join('\n');

  fs.writeFileSync(outputPath, redirectsContent + '\n');
  console.log(`Generated ${outputPath} with ${domainConfig.redirects.length} redirect rules`);
}

/**
 * Validate domain configuration
 */
function validateDomainConfig(appName) {
  const config = DOMAIN_CONFIG[appName];
  if (!config) {
    throw new Error(`Unknown application: ${appName}`);
  }

  // Validate domain format
  const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/;
  
  if (!domainRegex.test(config.primary)) {
    throw new Error(`Invalid primary domain format: ${config.primary}`);
  }

  for (const alias of config.aliases) {
    if (!domainRegex.test(alias)) {
      throw new Error(`Invalid alias domain format: ${alias}`);
    }
  }

  // Validate redirect rules
  for (const redirect of config.redirects) {
    if (!redirect.from || !redirect.to || !redirect.status) {
      throw new Error(`Invalid redirect rule: ${JSON.stringify(redirect)}`);
    }

    if (redirect.status < 300 || redirect.status >= 400) {
      throw new Error(`Invalid redirect status code: ${redirect.status}`);
    }
  }

  console.log(`Domain configuration for ${appName} is valid`);
  return true;
}

// CLI interface
if (require.main === module) {
  const command = process.argv[2];
  const appName = process.argv[3];

  if (!command || !appName) {
    console.log('Usage: node netlify-domain-config.js <command> <app-name>');
    console.log('Commands:');
    console.log('  validate <app-name>  - Validate domain configuration');
    console.log('  update <app-name>    - Update Netlify TOML configuration');
    console.log('  generate <app-name>  - Generate _redirects file');
    console.log('');
    console.log('App names: marketing, remix, docs');
    process.exit(1);
  }

  try {
    switch (command) {
      case 'validate':
        validateDomainConfig(appName);
        break;
      
      case 'update':
        const configPath = path.join('apps', appName === 'marketing' ? 'web' : appName, 'netlify.toml');
        updateNetlifyConfig(appName, configPath);
        break;
      
      case 'generate':
        const outputPath = path.join('apps', appName === 'marketing' ? 'web' : appName, 'public', '_redirects');
        generateRedirectsFile(appName, outputPath);
        break;
      
      default:
        throw new Error(`Unknown command: ${command}`);
    }
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

module.exports = {
  DOMAIN_CONFIG,
  generateRedirectRules,
  generateDomainConfig,
  updateNetlifyConfig,
  generateRedirectsFile,
  validateDomainConfig
};