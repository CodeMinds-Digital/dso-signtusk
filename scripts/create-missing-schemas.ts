#!/usr/bin/env tsx

/**
 * Create Missing Zod Schemas for SQLite Compatibility
 * 
 * This script creates temporary Zod schemas that are expected by the application
 * but not generated by our simplified SQLite Prisma schema.
 */

import fs from 'fs';
import path from 'path';

const SCHEMA_DIR = 'packages/prisma/generated/zod/modelSchema';

const schemas = [
    {
        name: 'RecipientSchema',
        content: `import { z } from 'zod';

export const RecipientSchema = z.object({
  id: z.number().int(),
  email: z.string(),
  name: z.string().optional(),
  documentId: z.number().int(),
  status: z.string().default('PENDING'),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Recipient = z.infer<typeof RecipientSchema>;
export default RecipientSchema;`
    },
    {
        name: 'SignatureSchema',
        content: `import { z } from 'zod';

export const SignatureSchema = z.object({
  id: z.number().int(),
  recipientId: z.number().int(),
  documentId: z.number().int(),
  signatureData: z.string().optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Signature = z.infer<typeof SignatureSchema>;
export default SignatureSchema;`
    },
    {
        name: 'TemplateSchema',
        content: `import { z } from 'zod';

export const TemplateSchema = z.object({
  id: z.number().int(),
  title: z.string(),
  userId: z.number().int(),
  teamId: z.number().int(),
  templateData: z.string().optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Template = z.infer<typeof TemplateSchema>;
export default TemplateSchema;`
    },
    {
        name: 'EnvelopeSchema',
        content: `import { z } from 'zod';

export const EnvelopeSchema = z.object({
  id: z.number().int(),
  title: z.string(),
  status: z.string().default('DRAFT'),
  userId: z.number().int(),
  teamId: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Envelope = z.infer<typeof EnvelopeSchema>;
export default EnvelopeSchema;`
    },
    {
        name: 'DocumentFieldSchema',
        content: `import { z } from 'zod';

export const DocumentFieldSchema = z.object({
  id: z.number().int(),
  documentId: z.number().int(),
  recipientId: z.number().int().optional(),
  type: z.string(),
  page: z.number().int(),
  positionX: z.number(),
  positionY: z.number(),
  width: z.number(),
  height: z.number(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type DocumentField = z.infer<typeof DocumentFieldSchema>;
export default DocumentFieldSchema;`
    },
    {
        name: 'ActivitySchema',
        content: `import { z } from 'zod';

export const ActivitySchema = z.object({
  id: z.number().int(),
  type: z.string(),
  userId: z.number().int().optional(),
  data: z.string().optional(),
  createdAt: z.coerce.date(),
});

export type Activity = z.infer<typeof ActivitySchema>;
export default ActivitySchema;`
    }
];

async function createMissingSchemas() {
    console.log('üîÑ Creating missing Zod schemas for SQLite compatibility...\n');

    // Ensure directory exists
    const schemaDir = path.join(process.cwd(), SCHEMA_DIR);
    if (!fs.existsSync(schemaDir)) {
        fs.mkdirSync(schemaDir, { recursive: true });
    }

    for (const schema of schemas) {
        const filePath = path.join(schemaDir, `${schema.name}.ts`);

        if (fs.existsSync(filePath)) {
            console.log(`‚ö†Ô∏è  ${schema.name}.ts already exists, skipping...`);
            continue;
        }

        fs.writeFileSync(filePath, schema.content);
        console.log(`‚úÖ Created ${schema.name}.ts`);
    }

    console.log('\nüéâ Missing schemas created successfully!');
    console.log('\nüí° Note: These are temporary schemas for SQLite compatibility.');
    console.log('For full functionality, use PostgreSQL with Docker.');
}

if (require.main === module) {
    createMissingSchemas().catch(console.error);
}

export { createMissingSchemas };